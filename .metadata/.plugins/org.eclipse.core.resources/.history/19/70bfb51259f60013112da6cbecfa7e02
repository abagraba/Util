package com.mimvista.cloud.organizer.verifier;

import java.io.IOException;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.axis.model.common.command.Command;

import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.google.common.collect.Sets;
import com.mimvista.archive.search.SearchResultsListener;
import com.mimvista.cloud.crypto.common.items.BasicStudyItem;
import com.mimvista.cloud.organizer.CloudOrganizer;
import com.mimvista.cloud.shared.common.S3SeriesURL;
import com.mimvista.mimcloud.commands.CloudCommands;
import com.mimvista.mimcloud.commands.GetS3SeriesHeadURLCommand;
import com.mimvista.mimcloud.commands.S3Commands.VerifyCommand;
import com.mimvista.mimcloud.connection.CloudClient;
import com.mimvista.mimcloud.connection.CloudResponseException;
import com.mimvista.mimcloud.connection.CloudResponseException.UnrecognizedResponseException;
import com.mimvista.util.progress.Progress;
import com.mimvista.util.work.MimTaskManager;

public class S3Verifier {

	private static final int CHUNK_SIZE = 300;

	/**
	 * Fills a map with the S3 URLs of the provided studies. Map is keyed by
	 * study DbKeyID in order to distinguish between multiple copies of the same
	 * study. This key gets a map between UIDs of the component series mapped to
	 * a S3SeriesURL containing DICOM URL and bundle data URLs if applicable.
	 */
	public static void getS3URLs(final CloudClient client, final List<BasicStudyItem> studies,
			final SearchResultsListener<Map<Long, Map<String, S3SeriesURL>>> listener) {
		final Map<Long, Map<String, S3SeriesURL>> results = Maps.newHashMap();
		MimTaskManager.background.execute(new Runnable() {
			@Override
			public void run() {
				Progress progress = null;
				if (listener != null)
					progress = listener.getSearchProgress();
				if (progress != null) {
					progress.setIndeterminate(false);
					progress.setProgress(0);
					progress.setTotal(studies.size());
					progress.start();
				}

				List<List<Long>> studyIDs = getChunkedIDs(studies);
				for (List<Long> ids : studyIDs) {
					GetS3SeriesHeadURLCommand command = new GetS3SeriesHeadURLCommand(client, ids);
					try {
						results.putAll(command.execute());
						if (progress != null)
							progress.increment(ids.size());
					}
					catch (CloudResponseException e) {
						e.printStackTrace();
					}
				}

				if (progress != null)
					progress.finish();
				if (listener != null)
					listener.setSearchResults(results);
			}
		});
	}

	/**
	 * Gets a chunked list of study DbKeyIds from the provided studies.
	 */
	private static List<List<Long>> getChunkedIDs(List<BasicStudyItem> studies) {
		List<List<Long>> studyIDs = Lists.newArrayList();
		int i = 0;
		List<Long> list = null;
		for (BasicStudyItem study : studies) {
			if (i++ / CHUNK_SIZE == 0) {
				list = Lists.newArrayList();
				studyIDs.add(list);
			}
			list.add(study.getDetails().getDbKeyId());
		}
		return studyIDs;
	}

	public static void verify(Map<Long, Map<String, S3SeriesURL>> studyList, Progress progress) {
		progress.setProgress(0);
		int total = 0;
		for (Map<String, S3SeriesURL> seriesList : studyList.values()) {
			for (S3SeriesURL urls : seriesList.values()) {
				total += urls.numURLs();
			}
		}
		progress.setTotal(total);

		Map<Long, Set<String>> failed = Maps.newHashMap();
		for (long studyDbId : studyList.keySet()) {
			Map<String, S3SeriesURL> seriesList = studyList.get(studyDbId);
			for (String seriesUID : seriesList.keySet()) {
				S3SeriesURL urls = seriesList.get(seriesUID);
				try {
					if (!new VerifyCommand(CloudOrganizer.getCloudClient(), urls.dicomURL).execute())
						addToMapSet(failed, studyDbId, seriesUID);
					
					
					
				}
				catch (UnrecognizedResponseException e) {
					e.printStackTrace();
				}
				catch (IOException e) {
					e.printStackTrace();
				}
				progress.increment(urls.numURLs());
			}
		}
	}

	private static <Key, SetValue> void addToMapSet(Map<Key, Set<SetValue>> map, Key key, SetValue value){
		if (!map.containsKey(key))
			map.put(key, new HashSet<SetValue>());
		map.get(key).add(value);
	}
	
}
