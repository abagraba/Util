package com.mimvista.cloud.server.groups;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Set;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.googlecode.objectify.Key;
import com.mimvista.cloud.models.CloudAccount;
import com.mimvista.cloud.models.CloudAccountRole;
import com.mimvista.cloud.server.halpers.ContactListHalper;
import com.mimvista.cloud.server.users.UserHalper;
import com.mimvista.cloud.shared.common.FoxExceptions;
import com.mimvista.cloud.shared.common.FoxExceptions.InsufficientPermissionsException;
import com.mimvista.cloud.shared.common.FoxExceptions.InvalidDecryptionPasswordException;
import com.mimvista.cloud.shared.common.FoxExceptions.AddingPatientToGroupException;
import com.mimvista.cloud.shared.common.RoleInfo;
import com.mimvista.cloud.shared.common.enums.AccountEnums.MembershipStatus;
import com.mimvista.cloud.shared.common.enums.AccountEnums.UserType;
import com.mimvista.cloud.shared.common.enums.EventType;
import com.mimvista.cloud.shared.common.enums.RolePermissions.GroupPermission;
import com.mimvista.cloud.shared.validators.ManagedUserFormValidationSchema;
import com.mimvista.cloud.shared.validators.MembershipsValidationSchema;

public class CreateMembershipsPerformer extends GroupMembershipPerformer {
	protected CloudAccount newMember;
	protected CloudAccountRole newRole;
	protected boolean newRoleIsAdminRole;
	protected byte[] decryptedUserPass;
	
	public CreateMembershipsPerformer(HttpServletRequest req, HttpServletResponse rsp, UserHalper currentUser, GroupHalper group, byte[] unencryptedGroupPass, CloudAccountRole newRole, CloudAccount newMember) throws InvalidDecryptionPasswordException  {
		super(req, rsp, currentUser, group);
		this.newMember = newMember;
		this.newRole = newRole;
		this.unencryptedGroupPass = unencryptedGroupPass;
		newRoleIsAdminRole = newRole.equals(group.getEntity().getAdminRole());
	}
	
	public CreateMembershipsPerformer(HttpServletRequest req, HttpServletResponse rsp, UserHalper currentUser, GroupHalper group, byte[] decryptedUserPass, byte[] unencryptedGroupPass, CloudAccountRole newRole, CloudAccount newMember) throws InvalidDecryptionPasswordException  {
		super(req, rsp, currentUser, group);
		this.newMember = newMember;
		this.newRole = newRole;
		this.unencryptedGroupPass = unencryptedGroupPass;
		newRoleIsAdminRole = newRole.equals(group.getEntity().getAdminRole());
		this.decryptedUserPass = decryptedUserPass;
	}
	
	@Override
	protected EventType getEventType() {
		return EventType.GROUP_ADD_MEMBER;
	}
	
	@Override
	protected boolean ableTo() {
		return user.hasGroupPermissions(group.getEntity(), GroupPermission.INVITE_MEMBERS);
	}
	
	@Override
	protected MembershipsValidationSchema getValidationSchema(Set<RoleInfo> accountRoleSet) {
		return new ManagedUserFormValidationSchema(accountRoleSet);
	}
	
	@Override
	protected void process() throws FoxExceptions {
		if(newMember.isManaged()) {
			Key<CloudAccount> membersHierarchyRoot = newMember.getRootAccountKey();
			//Something went wrong creating managed users if this is the case...
			if(membersHierarchyRoot == null) {
				throw new InsufficientPermissionsException("");
			}
			
			//Trying to add a managed user to a group in a different hierarchy
			if(!membersHierarchyRoot.equals(group.getEntity().getRootAccountKey())) {
				throw new InsufficientPermissionsException("Managed Users cannot be added to multiple group hierarchies."); //TODO externalize.
			}
			
			//Managed users can't be group admins
			if(newRoleIsAdminRole) {
				throw new InsufficientPermissionsException("Managed Users cannot be made administrators."); //TODO externalize.
			}
		}
		
		List<CloudAccount> toPut = new ArrayList<CloudAccount>();
		toPut.add(group.getEntity());
		//getDescendantAccounts is called before the for loop so that it doesn't have to be called for each user
		
		try {
			if (newMember.getUserFields().getUserType().equals(UserType.PATIENT)) {
				//Not sure how we want to handle this...
				throw new AddingPatientToGroupException();
			}
			
			UserHalper memberHalper = new UserHalper(newMember);
			if(memberHalper.getMembershipForGroup(group.getEntity()) != null) {
				return; //No need to throw an exception, just skip processing this account; the expected effect will be the same (the account being a member of the group)
			}
			
			ContactListHalper listHalper = new ContactListHalper(memberHalper);
			listHalper.makeContacts(user);
			
			byte[] encryptedPass = null;
			if (newRole.needsEncryptedPassword()) {
				encryptedPass = encryptPassword(memberHalper);
			}
			
			// This is to check if inherited admins will need to be created
			if (newRoleIsAdminRole){
				Collection<CloudAccount> subAccounts = group.getAllChildren();
				
				Set<CloudAccount> toAdd = addAdminToDescendants(memberHalper, newRole, subAccounts, decryptedUserPass);
				toPut.addAll(toAdd);
			}
			memberHalper.makeMyMembership(group.getEntity(), newRole, MembershipStatus.NORMAL, encryptedPass);
			
			toPut.add(newMember);
			associatedRole.put(newMember.getKey(), newRole.getKey());
		} finally {
			//If we bomb out adding a user after we've already added a couple others, need to persist memberships we completed so far
			if (!toPut.isEmpty()) {
				dao.bulkPut(toPut);
				dao.bulkFlush();
				affectedUsers.addAll(toPut);
			}
		}
	}
}
