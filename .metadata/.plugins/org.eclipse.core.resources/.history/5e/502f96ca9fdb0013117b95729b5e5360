public class Chunk {

	private byte headerMask = 0x20;

	private byte criticalMask = 0x8;
	private byte publicMask = 0x4;
	private byte validMask = 0x2;
	private byte unsafeMask = 0x1;

	private int size, crc;
	private String header;
	private byte[] data;

	byte chunkSpecs = 0;

	private boolean badHeader = false;

	public Chunk(int size, byte[] header, byte[] data, int crc) {
		this.size = size;
		this.header = new String(header);
		this.data = data;
		this.crc = crc;
		if ((header[3] & headerMask) == headerMask)
			chunkSpecs |= criticalMask;
		if ((header[2] & headerMask) == headerMask)
			chunkSpecs |= publicMask;
		if ((header[1] & headerMask) == headerMask)
			chunkSpecs |= validMask;
		else
			badHeader = false;
		if ((header[0] & headerMask) == headerMask)
			chunkSpecs |= unsafeMask;
	}

	public String toString() {
		if (size < 0)
			return "Invalid Chunk: Negative size.";
		if (badHeader)
			return "Invalid Chunk: Bad Header.";
		else
			return "Chunk: ["
					+ header
					+ "]\n\t"
					+ ((chunkSpecs & criticalMask) == criticalMask ? "Critical Chunk"
							: "Ancillary Chunk")
					+ "\n\t"
					+ ((chunkSpecs & publicMask) == publicMask ? "Public Chunk"
							: "Private Chunk") + "\n\tSize: " + size
					+ "\n\tCRC: " + crc + "\n\t" + chunkDescription() + "\n";
	}

	protected String chunkDescription() {
		int bytesPerLine = 120;
		String desc = "Raw Data:\n";
		for (int i = 0; i <= (data.length - 1) / bytesPerLine; i++) {
			int len = data.length - i * bytesPerLine;
			if (len > bytesPerLine)
				len = bytesPerLine;
			desc += new String(data, i * bytesPerLine, len);
			desc += "\n";
		}
		return desc;
	}

}
