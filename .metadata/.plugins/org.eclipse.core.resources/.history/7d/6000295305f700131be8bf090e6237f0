package com.mimvista.cloud.setup;

import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.google.appengine.api.urlfetch.HTTPResponse;
import com.google.common.collect.Maps;
import com.google.common.collect.Sets;
import com.google.gdata.util.common.base.Pair;
import com.mimvista.cloud.models.Series;
import com.mimvista.cloud.server.filestore.AsyncS3Client;
import com.mimvista.cloud.server.filestore.S3Service;
import com.mimvista.cloud.shared.common.enums.StudyEnums.S3Location;

public class TestableS3Service extends S3Service {
	private Set<Pair<S3Location, String>> existingFiles = Sets.newHashSet();
	private Map<Pair<S3Location, String>, Long> existingFileSize = Maps.newHashMap();
	private Set<Pair<S3Location, String>> deletedFiles = Sets.newHashSet();
	private Map<Pair<S3Location, String>, String> downloadURLs = Maps.newHashMap();
	private Set<Pair<S3Location, Pair<String,String>>> movedFiles = Sets.newHashSet();
	
	@Override
	public boolean checkFileExists(S3Location loc, String key) {
		return existingFiles.contains(new Pair<S3Location, String>(loc, key));
	}
	
	@Override
	public void delete(S3Location loc, String key) {
		Pair<S3Location, String> pair = new Pair<S3Location, String>(loc, key);
		deletedFiles.add(pair);
		existingFiles.remove(pair);
		existingFileSize.remove(pair);
	}
	
	@Override
	public String getDownloadUrl(S3Location loc, String key) {
		return downloadURLs.get(new Pair<S3Location, String>(loc, key));
	}
	
	@Override
	public String getHeadUrl(S3Location loc, String key) {
		return null;
	}
	
	public void addExistingFile(S3Location loc, String key, Long size) {
		Pair<S3Location, String> pair = new Pair<S3Location, String>(loc, key);
		existingFiles.add(pair);
		existingFileSize.put(pair, size);
	}

	public Set<Pair<S3Location, String>> getDeletedFiles() {
		return deletedFiles;
	}
	
	public void addDownloadUrl(S3Location loc, String key, String url) {
		downloadURLs.put(new Pair<S3Location, String>(loc, key), url);
	}
	
	private void doDeleteFiles(Series... series) {
		for (Series s : series) {
			for (String key : s.getAllUrls()) {
				delete(s.getS3Location(), key);
			}
		}
	}
	
	@Override
	public AsyncS3Client newAsyncDeletionClient(Series... series) {
		doDeleteFiles(series);
		return new AsyncS3Client() {
			boolean finished = false;
			
			@Override
			public boolean waitFinalResult() {
				return true;
			}
			
			@Override
			public boolean isFinished() {
				// I'm not sure whether this is good or bad. Ben votes bad.
				try {
					return finished;
				} finally {
					finished = true;
				}
			}
			
			@Override
			public void handleResponses(Collection<HTTPResponse> rsp) {
				throw new RuntimeException("This shouldn't actually happen.");
			}
			
			@Override
			public Map<String, Object> getAdditionalInfo() {
				return new HashMap<String, Object>();
			}
		};
	}
	
	public boolean doFilesExist(Series... series) {
		for (Series s : series) {
			for (String key : s.getAllUrls()) {
				if (!checkFileExists(s.getS3Location(), key))
					return false;
			}
		}
		return true;
	}
	
	@Override
	public AsyncS3Client newAsyncExistenceClient(final Series... series) {
		final boolean results = doFilesExist(series);
		
		Long fileSize = 0L;
		for (Series s : series) {
			for (String k : s.getAllUrls()) {
				Pair<S3Location, String> pair = new Pair<S3Location, String>(s.getS3Location(), k);
				Long size = existingFileSize.get(pair);
				if (size != null) {
					fileSize += size;
				}
			}
		}
		final Long totalSize = fileSize;
		
		return new AsyncS3Client() {
			boolean finished = false;

			@Override
			public boolean waitFinalResult() {
				return results;
			}
			
			@Override
			public boolean isFinished() {
				try {
					return finished;
				} finally {
					finished = true;
				}
			}
			
			@Override
			public void handleResponses(Collection<HTTPResponse> rsp) {
				throw new RuntimeException("This shouldn't actually happen.");
			}

			@Override
			public Map<String, Object> getAdditionalInfo() {
				Map<String, Object> info = new HashMap<String, Object>();
				info.put("studySize", totalSize);
				return info;
			}
		};
	}
	
	//TODO: we prolly should be able to test failures to copy
	private boolean doCopyFiles(S3Location loc, List<Pair<String, String>> srcDestPairs) {
		for (Pair<String,String> p : srcDestPairs) {
			movedFiles.add(Pair.of(loc, p));
		}
		
		return true;
	}

	@Override
	public AsyncS3Client newAsyncCopyClient(S3Location loc, List<Pair<String, String>> srcDestPairs) {
		final boolean results = doCopyFiles(loc, srcDestPairs);
		
		return new AsyncS3Client() {
			boolean finished = false;
			
			@Override
			public boolean waitFinalResult() {
				return results;
			}
			
			@Override
			public boolean isFinished() {
				try {
					return finished;
				} finally {
					finished = true;
				}
			}
			
			@Override
			public Map<String, Object> getAdditionalInfo() {
				return new HashMap<String, Object>();
			}
			
			@Override
			public void handleResponses(Collection<HTTPResponse> rsps) {
				throw new RuntimeException("This shouldn't actually happen.");
			}
		};
	}


}
