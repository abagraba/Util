package com.mimvista.cloud.organizer.verifier;

import java.io.IOException;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.axis.model.common.command.Command;

import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.google.common.collect.Sets;
import com.mimvista.Nullable;
import com.mimvista.archive.search.SearchResultsListener;
import com.mimvista.cloud.crypto.common.items.BasicStudyItem;
import com.mimvista.cloud.organizer.CloudOrganizer;
import com.mimvista.cloud.shared.common.S3SeriesURL;
import com.mimvista.cloud.shared.common.mim.StudyDetails;
import com.mimvista.mimcloud.commands.CloudCommands;
import com.mimvista.mimcloud.commands.GetS3SeriesHeadURLCommand;
import com.mimvista.mimcloud.commands.S3Commands.VerifyCommand;
import com.mimvista.mimcloud.connection.CloudClient;
import com.mimvista.mimcloud.connection.CloudResponseException;
import com.mimvista.mimcloud.connection.CloudResponseException.UnrecognizedResponseException;
import com.mimvista.util.MIMLog;
import com.mimvista.util.progress.Progress;
import com.mimvista.util.work.MimTaskManager;

public class S3Verifier {

	private static final int CHUNK_SIZE = 300;

	/**
	 * Fills a map with the S3 URLs of the provided studies. Map is keyed by
	 * study DbKeyID in order to distinguish between multiple copies of the same
	 * study. This key gets a map between UIDs of the component series mapped to
	 * a S3SeriesURL containing DICOM URL and bundle data URLs if applicable.
	 * 
	 * @return
	 */
	public static Map<Long, Map<String, S3SeriesURL>> getS3URLs(final CloudClient client, final List<StudyDetails> studies, @Nullable Progress progress) {
		final Map<Long, Map<String, S3SeriesURL>> results = Maps.newHashMap();
		if (progress != null) {
			progress.setDescription(VerifierTask.props.getProperty("PROGRESS_FETCHING"));
			progress.setProgress(0);
			progress.setTotal(studies.size());
			progress.start();
		}

		List<List<Long>> studyIDs = getChunkedIDs(studies);
		for (List<Long> ids : studyIDs) {
			GetS3SeriesHeadURLCommand command = new GetS3SeriesHeadURLCommand(client, ids);
			try {
				results.putAll(command.execute());
				if (progress != null)
					progress.increment(ids.size());
			}
			catch (CloudResponseException e) {
				e.printStackTrace();
			}
		}

		if (progress != null)
			progress.finish();
		return results;
	}

	/**
	 * Gets a chunked list of study DbKeyIds from the provided studies.
	 */
	private static List<List<Long>> getChunkedIDs(List<StudyDetails> studies) {
		List<List<Long>> studyIDs = Lists.newArrayList();
		int i = 0;
		List<Long> list = null;
		for (StudyDetails study : studies) {
			if (i++ / CHUNK_SIZE == 0) {
				list = Lists.newArrayList();
				studyIDs.add(list);
			}
			list.add(study.getDbKeyId());
		}
		return studyIDs;
	}

	public static Map<Long, Set<String>> verify(Map<Long, Map<String, S3SeriesURL>> studyList, @Nullable Progress progress) {
		if (progress != null) {
			progress.setDescription(VerifierTask.props.getProperty("PROGRESS_VERIFYING"));
			progress.setProgress(0);
			int total = 0;
			for (Map<String, S3SeriesURL> seriesList : studyList.values()) {
				for (S3SeriesURL urls : seriesList.values()) {
					total += urls.numURLs();
				}
			}
			progress.setTotal(total);
			progress.start();
		}

		Map<Long, Set<String>> failed = Maps.newHashMap();
		for (long studyDbId : studyList.keySet()) {
			Map<String, S3SeriesURL> seriesList = studyList.get(studyDbId);
			for (String seriesUID : seriesList.keySet()) {
				S3SeriesURL urls = seriesList.get(seriesUID);
				if (urls.numURLs() != 0) {
					try {
						if (urls.dicomURL != null && !new VerifyCommand(CloudOrganizer.getCloudClient(), urls.dicomURL).execute())
							addToMapSet(failed, studyDbId, seriesUID);
						if (progress != null)
							progress.increment();
						for (String bundleURL : urls.bundleURLs) {
							if (bundleURL != null && !new VerifyCommand(CloudOrganizer.getCloudClient(), bundleURL).execute())
								addToMapSet(failed, studyDbId, seriesUID);
							if (progress != null)
								progress.increment();
						}
					}
					catch (UnrecognizedResponseException e) {
						MIMLog.error("Failed to verify study " + studyDbId, S3Verifier.class);
					}
					catch (IOException e) {
						MIMLog.error("Failed to verify study " + studyDbId, S3Verifier.class);
					}
				}
				else {
					addToMapSet(failed, studyDbId, seriesUID);
				}
			}
		}

		if (progress != null)
			progress.finish();
		return failed;
	}

	private static <Key, SetValue> void addToMapSet(Map<Key, Set<SetValue>> map, Key key, SetValue value) {
		if (!map.containsKey(key))
			map.put(key, new HashSet<SetValue>());
		map.get(key).add(value);
	}

}
